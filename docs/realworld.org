* JUCE host

1. create
   1. contructEffect
      1. calls =VSTPluginMain= to get a plugin
      2. checks =effect->magic=
      3. checks =effect->resvd2!=0=
   2. set =effect->resvd2= to 0
   3. calls =effIdentify(0,0,NULL,0.))= (ignores result)
   4. calls =effSetSampleRate(0,0,NULL,sampleRate)=
   5. calls =effSetBlockSize(0,blockSize,NULL, 0.f)=
   6. calls =effOpen(0,0,NULL,0.))=
   7. queryBusIO
      1. calls =effSetSpeakerArrangement(0, ?, ?, 0.f)=
      2. getSpeakerArrangementWrapper
         1. ?
      3. =effGetInputProperties(ch=0..n, 0, &pinProps, 0.0f)=
      4. =effGetOutputProperties(ch=0..n, 0, &pinProps, 0.0f)=
   8. VSTPluginInstance
      1. =effCanBeAutomated(param=0..n, 0, 0, 0, 0)=


* REAPER host

#+BEGIN_SRC C
/* init */
effect->dispatcher(effOpen, 0, 0, (nil), 0.000000);
effect->dispatcher(effSetSampleRate, 0, 0, (nil), 44100.000000);
effect->dispatcher(effSetBlockSize, 0, 512, (nil), 0.000000);
effect->dispatcher(effGetEffectName, 0, 0, 0x7ffcf7237fc0, 0.000000);
effect->dispatcher(effGetVendorString, 0, 0, 0x7ffcf7237fc0, 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab4617, 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab4af0, 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab4670, 0.000000);
effect->dispatcher(effGetVstVersion, 0, 0, (nil), 0.000000);
effect->dispatcher(12, 0, 1, (nil), 0.000000);
effect->dispatcher(71, 0, 0, (nil), 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab4684, 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab4695, 0.000000);
effect->dispatcher(35, 0, 0, (nil), 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab46a9, 0.000000);
effect->dispatcher(effCanDo, 0, 0, 0xab46b7, 0.000000);
effect->dispatcher(effGetProgram, 0, 0, (nil), 0.000000);
effect->dispatcher(effGetChunk, 0, 0, 0x7ffcf722fd10, 0.000000);
effect->dispatcher(effSetProgram, 0, 0, (nil), 0.000000);
effect->dispatcher(effGetProgramName, 0, 0, 0x7ffcf7237dc0, 0.000000);
effect->dispatcher(effGetProgram, 0, 0, (nil), 0.000000);

/* start playback */
effect->dispatcher(12, 0, 0, (nil), 0.000000);
effect->dispatcher(12, 0, 1, (nil), 0.000000);

/* de-init */
effect->dispatcher(12, 0, 0, (nil), 0.000000);
effect->dispatcher(12, 0, 1, (nil), 0.000000);
effect->dispatcher(12, 0, 0, (nil), 0.000000);
effect->dispatcher(12, 0, 1, (nil), 0.000000);
effect->dispatcher(72, 0, 0, (nil), 0.000000);
effect->dispatcher(12, 0, 0, (nil), 0.000000);
effect->dispatcher(effClose, 0, 0, (nil), 0.000000);
#+END_SRC

hmm, now


* REAPER plugins

plugins that come with REAPER fail to instantiate.
however, in the `VSTPluginMain` function they call the host
with two callbacks:
#+BEGIN_SRC C
hostDispatcher(0, 0xDEADBEEF, 0xDEADFOOD, 0, "DB2SLIDER", 0.f);
hostDispatcher(0, 0xDEADBEEF, 0xDEADFOOD, 0, "SLIDER2DB", 0.f);
#+END_SRC

I *think* that the plugin is asking for shared functions.
At least, if we return a function pointer, the `reacomp.vst` plugin loads!

we can then load the following plugins:
- REAPER/Plugins/FX/reacomp.vst.so
- REAPER/Plugins/FX/readelay.vst.so
- REAPER/Plugins/FX/reagate.vst.so
- REAPER/Plugins/FX/reasyndr.vst.so
- REAPER/Plugins/FX/reasynth.vst.so
- REAPER/Plugins/FX/reatune.vst.so
- REAPER/Plugins/FX/reaverbate.vst.so
- REAPER/Plugins/FX/reavocode.vst.so



* Categories as reported by REAPER

** Delay
- ReaDelay
** Dynamics
- ReaComp
- ReaXComp
** EQ
- ReaEQ
** External
- ReaCast
- ReaInsert
- ReaNINJAM
- ReaStream (8ch)
** Gate
- ReaGate
** MIDI
- ReaControlMIDI
** Pitch Correction
- ReaPitch
** Reverb
- ReaVerb
- ReaVerbate
** Sampler
- ReaSamplOmatic5000
** Surround
- ReaSurround
** Synth
- Digits
- hypercyclic
- tonespace
- ReaSynDr
- ReaSynth

** Tools
- ReaFir
- ReaVocode
- ReaVoice
** Tuner
- ReaTune



* VstPinProperties

#+BEGIN_SRC C++
Vst2::VstPinProperties pinProps;
if (dispatch (Vst2::effGetOutputProperties, index, 0, &pinProps, 0.0f) != 0)
  return String (pinProps.label, sizeof (pinProps.label));
#+END_SRC

** VstPinProperties.flags

if (kVstPinUseSpeaker): layout=VstPinProperties.arrangementType
else if (kVstPinIsStereo): layout=stereo
else: layout=mono

** VstPinProperties.arrangementType
->  SpeakerMappings::vstArrangementTypeToChannelSet

SpeakerMappings::vstArrangementTypeToChannelSet (pinProps.arrangementType, 0);
const Vst2::VstSpeakerArrangement* arr = (isInput ? inArr : outArr);
layout = SpeakerMappings::vstArrangementTypeToChannelSet (*arr);


#+BEGIN_SRC C
struct {
  char label[64];
  int flags;
  int arrangmentType;
  char shortLabel[8];
}
#+END_SRC

has =arrangementType=0; flags=3= for our "normal" test plugins
and =arrangementType=1; flags=2= for our the reaper plugins
